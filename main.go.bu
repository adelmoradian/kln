package main

import (
	"flag"
	"log"
	"os"
)

// type Items struct {
// Items []kln.ResourceIdentifier `yaml:"items"`
// }

var (
	requiredFlags = []string{"kube-config"}
)

var (
	flagCmd = flag.NewFlagSet("flag", flag.ExitOnError)
	listCmd = flag.NewFlagSet("list", flag.ExitOnError)
)

var (
	subcommands = map[string]*flag.FlagSet{
		flagCmd.Name(): flagCmd,
		listCmd.Name(): listCmd,
	}
)

func main() {

	cmd := os.Args[1]
	fs, ok := subcommands[cmd]
	if !ok {
		log.Fatalf("[ERROR] unknown subcommand. %s.\n%s", cmd, flag.ErrHelp)
	}
	fs.Parse(os.Args[2:])

	// 	var item Items

	// 	filename, _ := filepath.Abs("./kln.yaml")
	// 	yamlFile, err := ioutil.ReadFile(filename)
	// 	if err != nil {
	// 		panic(err)
	// 	}
	// 	err = yaml.Unmarshal(yamlFile, &item)
	// 	if err != nil {
	// 		panic(err)
	// 	}

	// 	for i, item := range item.Items {

	// 		fmt.Println("item ", i)
	// 		fmt.Printf("config.ApiVersion: %v\n", item.ApiVersion)
	// 		fmt.Printf("config.Description: %v\n", item.Description)
	// 		fmt.Printf("config.GVR: %T\n", item.GVR)
	// 		fmt.Printf("config.Kind: %v\n", item.Kind)
	// 		fmt.Printf("config.Metadata: %v\n", item.Metadata)
	// 		fmt.Printf("config.Spec: %v\n", item.Spec)
	// 		fmt.Printf("config.Status: %v\n", item.Status)
	// 		fmt.Printf("config.Name: %v\n", item.Name)
	// 		fmt.Printf("config.MinAge: %v\n", item.MinAge)
	// 	}

	// if err := root(os.Args[1:]); err != nil {
	// 	fmt.Println(err)
	// 	os.Exit(1)
	// }

	// a := kln.ResourceIdentifier{
	// 	GVR: schema.GroupVersionResource{
	// 		Group:    "tekton.dev",
	// 		Version:  "v1beta1",
	// 		Resource: "pipelineruns",
	// 	},
	// 	MinAge:     160,
	// 	ApiVersion: "tekton.dev/v1beta1",
	// 	Kind:       "PipelineRun",
	// 	// Metadata: map[string]interface{}{
	// 	// "namespace": "ci-shared",
	// 	// },
	// 	Metadata: map[string]interface{}{},
	// 	Spec:     map[string]interface{}{},
	// 	// Status: map[string]interface{}{},
	// 	Status: map[string]interface{}{
	// 		"conditions": []interface{}{
	// 			map[string]interface{}{
	// 				"status": "False",
	// 				"type":   "Succeeded",
	// 				"reason": "CouldntGetPipeline",
	// 			},
	// 		},
	// 	},
	// }
	// var kubeconfig *string
	// if home := homedir.HomeDir(); home != "" {
	// 	kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) abs path to kubeconfig file")
	// } else {
	// 	kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	// }
	// flag.Parse()

	// config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	// if err != nil {
	// 	panic(err)
	// }
	// client, err := dynamic.NewForConfig(config)
	// if err != nil {
	// 	panic(err)
	// }

	// list := kln.ListResources(client, a)
	// for _, item := range list {
	// 	age := item.GetCreationTimestamp()
	// 	ns := item.GetNamespace()
	// 	name := item.GetName()
	// 	apiversion := item.GetAPIVersion()
	// 	kind := item.GetKind()
	// 	stuff := item.Object["status"].(map[string]interface{})["conditions"].([]interface{})[0].(map[string]interface{})
	// 	status := stuff["status"].(string)
	// 	typeof := stuff["type"].(string)
	// 	reason := stuff["reason"]
	// 	fmt.Printf("--- Name: %s, NS: %s, Age: %s, apiVersion: %s, kind: %s --- %s is %s because %s\n", name, ns, time.Since(age.Time), apiversion, kind, typeof, status, reason)
	// }

}
